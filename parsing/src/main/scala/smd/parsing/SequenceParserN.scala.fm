package smd
package parsing

// This file is automatically generated from a freemarker template.
// Template: ${.template_name}
// Last Generated: ${.now}

<#assign MaxN=16>
<#list 2..MaxN as n>
<#assign TS><#list 1..n as i>T${i}<#if i_has_next>, </#if></#list></#assign>

/** Parses ${n} expressions, providing strongly-typed results.
  *
  <#list 1..n as i>
  * @param  p${i} the parser at position ${i} in the sequence.
  * @tparam T${i} the product type of the parser at position ${i} in the sequence.
  </#list>
  */
case class SequenceParser${n}[<#list 1..n as i>+T${i}<#if i_has_next>, </#if></#list>](
  <#list 1..n as i>
  p${i}: Parser[T${i}]<#if i_has_next>,</#if>
  </#list>
) extends SequenceParserLike[(<#list 1..n as i>T${i}<#if i_has_next>, </#if></#list>)] { seq =>

  lazy val sequence: IndexedSeq[Parser[Any]] = IndexedSeq(<#list 1..n as i>p${i}<#if i_has_next>, </#if></#list>)

  def parse(context: ParsingContext): ParsingResult[(<#list 1..n as i>T${i}<#if i_has_next>, </#if></#list>)] = {
    val rb = context.resultBuilder

    <#list 1..n as i>
    val r${i} = p${i}.parse(context)
    if(r${i}.rejected) return rb.reject

    </#list>

    rb.accept((<#list 1..n as i>r${i}.product<#if i_has_next>, </#if></#list>))
  }
}
</#list>
