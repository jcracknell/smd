package smd
package parsing

// This file is automatically generated from a freemarker template.
// Template: smd/parsing/SequenceParserN.scala.fm
// Last Generated: Dec 20, 2013 5:23:00 PM


/** Parses 2 expressions, providing strongly-typed results.
  *
  * @param  p1 the parser at position 1 in the sequence.
  * @tparam T1 the product type of the parser at position 1 in the sequence.
  * @param  p2 the parser at position 2 in the sequence.
  * @tparam T2 the product type of the parser at position 2 in the sequence.
  */
case class SequenceParser2[+T1, +T2](
  p1: Parser[T1],
  p2: Parser[T2]
) extends SequenceParserLike[(T1, T2)] { seq =>

  lazy val sequence: IndexedSeq[Parser[Any]] = IndexedSeq(p1, p2)

  def parse(context: ParsingContext): ParsingResult[(T1, T2)] = {
    val rb = context.resultBuilder

    val r1 = p1.parse(context)
    if(r1.rejected) return rb.reject

    val r2 = p2.parse(context)
    if(r2.rejected) return rb.reject


    rb.accept((r1.product, r2.product))
  }
}

/** Parses 3 expressions, providing strongly-typed results.
  *
  * @param  p1 the parser at position 1 in the sequence.
  * @tparam T1 the product type of the parser at position 1 in the sequence.
  * @param  p2 the parser at position 2 in the sequence.
  * @tparam T2 the product type of the parser at position 2 in the sequence.
  * @param  p3 the parser at position 3 in the sequence.
  * @tparam T3 the product type of the parser at position 3 in the sequence.
  */
case class SequenceParser3[+T1, +T2, +T3](
  p1: Parser[T1],
  p2: Parser[T2],
  p3: Parser[T3]
) extends SequenceParserLike[(T1, T2, T3)] { seq =>

  lazy val sequence: IndexedSeq[Parser[Any]] = IndexedSeq(p1, p2, p3)

  def parse(context: ParsingContext): ParsingResult[(T1, T2, T3)] = {
    val rb = context.resultBuilder

    val r1 = p1.parse(context)
    if(r1.rejected) return rb.reject

    val r2 = p2.parse(context)
    if(r2.rejected) return rb.reject

    val r3 = p3.parse(context)
    if(r3.rejected) return rb.reject


    rb.accept((r1.product, r2.product, r3.product))
  }
}

/** Parses 4 expressions, providing strongly-typed results.
  *
  * @param  p1 the parser at position 1 in the sequence.
  * @tparam T1 the product type of the parser at position 1 in the sequence.
  * @param  p2 the parser at position 2 in the sequence.
  * @tparam T2 the product type of the parser at position 2 in the sequence.
  * @param  p3 the parser at position 3 in the sequence.
  * @tparam T3 the product type of the parser at position 3 in the sequence.
  * @param  p4 the parser at position 4 in the sequence.
  * @tparam T4 the product type of the parser at position 4 in the sequence.
  */
case class SequenceParser4[+T1, +T2, +T3, +T4](
  p1: Parser[T1],
  p2: Parser[T2],
  p3: Parser[T3],
  p4: Parser[T4]
) extends SequenceParserLike[(T1, T2, T3, T4)] { seq =>

  lazy val sequence: IndexedSeq[Parser[Any]] = IndexedSeq(p1, p2, p3, p4)

  def parse(context: ParsingContext): ParsingResult[(T1, T2, T3, T4)] = {
    val rb = context.resultBuilder

    val r1 = p1.parse(context)
    if(r1.rejected) return rb.reject

    val r2 = p2.parse(context)
    if(r2.rejected) return rb.reject

    val r3 = p3.parse(context)
    if(r3.rejected) return rb.reject

    val r4 = p4.parse(context)
    if(r4.rejected) return rb.reject


    rb.accept((r1.product, r2.product, r3.product, r4.product))
  }
}

/** Parses 5 expressions, providing strongly-typed results.
  *
  * @param  p1 the parser at position 1 in the sequence.
  * @tparam T1 the product type of the parser at position 1 in the sequence.
  * @param  p2 the parser at position 2 in the sequence.
  * @tparam T2 the product type of the parser at position 2 in the sequence.
  * @param  p3 the parser at position 3 in the sequence.
  * @tparam T3 the product type of the parser at position 3 in the sequence.
  * @param  p4 the parser at position 4 in the sequence.
  * @tparam T4 the product type of the parser at position 4 in the sequence.
  * @param  p5 the parser at position 5 in the sequence.
  * @tparam T5 the product type of the parser at position 5 in the sequence.
  */
case class SequenceParser5[+T1, +T2, +T3, +T4, +T5](
  p1: Parser[T1],
  p2: Parser[T2],
  p3: Parser[T3],
  p4: Parser[T4],
  p5: Parser[T5]
) extends SequenceParserLike[(T1, T2, T3, T4, T5)] { seq =>

  lazy val sequence: IndexedSeq[Parser[Any]] = IndexedSeq(p1, p2, p3, p4, p5)

  def parse(context: ParsingContext): ParsingResult[(T1, T2, T3, T4, T5)] = {
    val rb = context.resultBuilder

    val r1 = p1.parse(context)
    if(r1.rejected) return rb.reject

    val r2 = p2.parse(context)
    if(r2.rejected) return rb.reject

    val r3 = p3.parse(context)
    if(r3.rejected) return rb.reject

    val r4 = p4.parse(context)
    if(r4.rejected) return rb.reject

    val r5 = p5.parse(context)
    if(r5.rejected) return rb.reject


    rb.accept((r1.product, r2.product, r3.product, r4.product, r5.product))
  }
}

/** Parses 6 expressions, providing strongly-typed results.
  *
  * @param  p1 the parser at position 1 in the sequence.
  * @tparam T1 the product type of the parser at position 1 in the sequence.
  * @param  p2 the parser at position 2 in the sequence.
  * @tparam T2 the product type of the parser at position 2 in the sequence.
  * @param  p3 the parser at position 3 in the sequence.
  * @tparam T3 the product type of the parser at position 3 in the sequence.
  * @param  p4 the parser at position 4 in the sequence.
  * @tparam T4 the product type of the parser at position 4 in the sequence.
  * @param  p5 the parser at position 5 in the sequence.
  * @tparam T5 the product type of the parser at position 5 in the sequence.
  * @param  p6 the parser at position 6 in the sequence.
  * @tparam T6 the product type of the parser at position 6 in the sequence.
  */
case class SequenceParser6[+T1, +T2, +T3, +T4, +T5, +T6](
  p1: Parser[T1],
  p2: Parser[T2],
  p3: Parser[T3],
  p4: Parser[T4],
  p5: Parser[T5],
  p6: Parser[T6]
) extends SequenceParserLike[(T1, T2, T3, T4, T5, T6)] { seq =>

  lazy val sequence: IndexedSeq[Parser[Any]] = IndexedSeq(p1, p2, p3, p4, p5, p6)

  def parse(context: ParsingContext): ParsingResult[(T1, T2, T3, T4, T5, T6)] = {
    val rb = context.resultBuilder

    val r1 = p1.parse(context)
    if(r1.rejected) return rb.reject

    val r2 = p2.parse(context)
    if(r2.rejected) return rb.reject

    val r3 = p3.parse(context)
    if(r3.rejected) return rb.reject

    val r4 = p4.parse(context)
    if(r4.rejected) return rb.reject

    val r5 = p5.parse(context)
    if(r5.rejected) return rb.reject

    val r6 = p6.parse(context)
    if(r6.rejected) return rb.reject


    rb.accept((r1.product, r2.product, r3.product, r4.product, r5.product, r6.product))
  }
}

/** Parses 7 expressions, providing strongly-typed results.
  *
  * @param  p1 the parser at position 1 in the sequence.
  * @tparam T1 the product type of the parser at position 1 in the sequence.
  * @param  p2 the parser at position 2 in the sequence.
  * @tparam T2 the product type of the parser at position 2 in the sequence.
  * @param  p3 the parser at position 3 in the sequence.
  * @tparam T3 the product type of the parser at position 3 in the sequence.
  * @param  p4 the parser at position 4 in the sequence.
  * @tparam T4 the product type of the parser at position 4 in the sequence.
  * @param  p5 the parser at position 5 in the sequence.
  * @tparam T5 the product type of the parser at position 5 in the sequence.
  * @param  p6 the parser at position 6 in the sequence.
  * @tparam T6 the product type of the parser at position 6 in the sequence.
  * @param  p7 the parser at position 7 in the sequence.
  * @tparam T7 the product type of the parser at position 7 in the sequence.
  */
case class SequenceParser7[+T1, +T2, +T3, +T4, +T5, +T6, +T7](
  p1: Parser[T1],
  p2: Parser[T2],
  p3: Parser[T3],
  p4: Parser[T4],
  p5: Parser[T5],
  p6: Parser[T6],
  p7: Parser[T7]
) extends SequenceParserLike[(T1, T2, T3, T4, T5, T6, T7)] { seq =>

  lazy val sequence: IndexedSeq[Parser[Any]] = IndexedSeq(p1, p2, p3, p4, p5, p6, p7)

  def parse(context: ParsingContext): ParsingResult[(T1, T2, T3, T4, T5, T6, T7)] = {
    val rb = context.resultBuilder

    val r1 = p1.parse(context)
    if(r1.rejected) return rb.reject

    val r2 = p2.parse(context)
    if(r2.rejected) return rb.reject

    val r3 = p3.parse(context)
    if(r3.rejected) return rb.reject

    val r4 = p4.parse(context)
    if(r4.rejected) return rb.reject

    val r5 = p5.parse(context)
    if(r5.rejected) return rb.reject

    val r6 = p6.parse(context)
    if(r6.rejected) return rb.reject

    val r7 = p7.parse(context)
    if(r7.rejected) return rb.reject


    rb.accept((r1.product, r2.product, r3.product, r4.product, r5.product, r6.product, r7.product))
  }
}

/** Parses 8 expressions, providing strongly-typed results.
  *
  * @param  p1 the parser at position 1 in the sequence.
  * @tparam T1 the product type of the parser at position 1 in the sequence.
  * @param  p2 the parser at position 2 in the sequence.
  * @tparam T2 the product type of the parser at position 2 in the sequence.
  * @param  p3 the parser at position 3 in the sequence.
  * @tparam T3 the product type of the parser at position 3 in the sequence.
  * @param  p4 the parser at position 4 in the sequence.
  * @tparam T4 the product type of the parser at position 4 in the sequence.
  * @param  p5 the parser at position 5 in the sequence.
  * @tparam T5 the product type of the parser at position 5 in the sequence.
  * @param  p6 the parser at position 6 in the sequence.
  * @tparam T6 the product type of the parser at position 6 in the sequence.
  * @param  p7 the parser at position 7 in the sequence.
  * @tparam T7 the product type of the parser at position 7 in the sequence.
  * @param  p8 the parser at position 8 in the sequence.
  * @tparam T8 the product type of the parser at position 8 in the sequence.
  */
case class SequenceParser8[+T1, +T2, +T3, +T4, +T5, +T6, +T7, +T8](
  p1: Parser[T1],
  p2: Parser[T2],
  p3: Parser[T3],
  p4: Parser[T4],
  p5: Parser[T5],
  p6: Parser[T6],
  p7: Parser[T7],
  p8: Parser[T8]
) extends SequenceParserLike[(T1, T2, T3, T4, T5, T6, T7, T8)] { seq =>

  lazy val sequence: IndexedSeq[Parser[Any]] = IndexedSeq(p1, p2, p3, p4, p5, p6, p7, p8)

  def parse(context: ParsingContext): ParsingResult[(T1, T2, T3, T4, T5, T6, T7, T8)] = {
    val rb = context.resultBuilder

    val r1 = p1.parse(context)
    if(r1.rejected) return rb.reject

    val r2 = p2.parse(context)
    if(r2.rejected) return rb.reject

    val r3 = p3.parse(context)
    if(r3.rejected) return rb.reject

    val r4 = p4.parse(context)
    if(r4.rejected) return rb.reject

    val r5 = p5.parse(context)
    if(r5.rejected) return rb.reject

    val r6 = p6.parse(context)
    if(r6.rejected) return rb.reject

    val r7 = p7.parse(context)
    if(r7.rejected) return rb.reject

    val r8 = p8.parse(context)
    if(r8.rejected) return rb.reject


    rb.accept((r1.product, r2.product, r3.product, r4.product, r5.product, r6.product, r7.product, r8.product))
  }
}

/** Parses 9 expressions, providing strongly-typed results.
  *
  * @param  p1 the parser at position 1 in the sequence.
  * @tparam T1 the product type of the parser at position 1 in the sequence.
  * @param  p2 the parser at position 2 in the sequence.
  * @tparam T2 the product type of the parser at position 2 in the sequence.
  * @param  p3 the parser at position 3 in the sequence.
  * @tparam T3 the product type of the parser at position 3 in the sequence.
  * @param  p4 the parser at position 4 in the sequence.
  * @tparam T4 the product type of the parser at position 4 in the sequence.
  * @param  p5 the parser at position 5 in the sequence.
  * @tparam T5 the product type of the parser at position 5 in the sequence.
  * @param  p6 the parser at position 6 in the sequence.
  * @tparam T6 the product type of the parser at position 6 in the sequence.
  * @param  p7 the parser at position 7 in the sequence.
  * @tparam T7 the product type of the parser at position 7 in the sequence.
  * @param  p8 the parser at position 8 in the sequence.
  * @tparam T8 the product type of the parser at position 8 in the sequence.
  * @param  p9 the parser at position 9 in the sequence.
  * @tparam T9 the product type of the parser at position 9 in the sequence.
  */
case class SequenceParser9[+T1, +T2, +T3, +T4, +T5, +T6, +T7, +T8, +T9](
  p1: Parser[T1],
  p2: Parser[T2],
  p3: Parser[T3],
  p4: Parser[T4],
  p5: Parser[T5],
  p6: Parser[T6],
  p7: Parser[T7],
  p8: Parser[T8],
  p9: Parser[T9]
) extends SequenceParserLike[(T1, T2, T3, T4, T5, T6, T7, T8, T9)] { seq =>

  lazy val sequence: IndexedSeq[Parser[Any]] = IndexedSeq(p1, p2, p3, p4, p5, p6, p7, p8, p9)

  def parse(context: ParsingContext): ParsingResult[(T1, T2, T3, T4, T5, T6, T7, T8, T9)] = {
    val rb = context.resultBuilder

    val r1 = p1.parse(context)
    if(r1.rejected) return rb.reject

    val r2 = p2.parse(context)
    if(r2.rejected) return rb.reject

    val r3 = p3.parse(context)
    if(r3.rejected) return rb.reject

    val r4 = p4.parse(context)
    if(r4.rejected) return rb.reject

    val r5 = p5.parse(context)
    if(r5.rejected) return rb.reject

    val r6 = p6.parse(context)
    if(r6.rejected) return rb.reject

    val r7 = p7.parse(context)
    if(r7.rejected) return rb.reject

    val r8 = p8.parse(context)
    if(r8.rejected) return rb.reject

    val r9 = p9.parse(context)
    if(r9.rejected) return rb.reject


    rb.accept((r1.product, r2.product, r3.product, r4.product, r5.product, r6.product, r7.product, r8.product, r9.product))
  }
}

/** Parses 10 expressions, providing strongly-typed results.
  *
  * @param  p1 the parser at position 1 in the sequence.
  * @tparam T1 the product type of the parser at position 1 in the sequence.
  * @param  p2 the parser at position 2 in the sequence.
  * @tparam T2 the product type of the parser at position 2 in the sequence.
  * @param  p3 the parser at position 3 in the sequence.
  * @tparam T3 the product type of the parser at position 3 in the sequence.
  * @param  p4 the parser at position 4 in the sequence.
  * @tparam T4 the product type of the parser at position 4 in the sequence.
  * @param  p5 the parser at position 5 in the sequence.
  * @tparam T5 the product type of the parser at position 5 in the sequence.
  * @param  p6 the parser at position 6 in the sequence.
  * @tparam T6 the product type of the parser at position 6 in the sequence.
  * @param  p7 the parser at position 7 in the sequence.
  * @tparam T7 the product type of the parser at position 7 in the sequence.
  * @param  p8 the parser at position 8 in the sequence.
  * @tparam T8 the product type of the parser at position 8 in the sequence.
  * @param  p9 the parser at position 9 in the sequence.
  * @tparam T9 the product type of the parser at position 9 in the sequence.
  * @param  p10 the parser at position 10 in the sequence.
  * @tparam T10 the product type of the parser at position 10 in the sequence.
  */
case class SequenceParser10[+T1, +T2, +T3, +T4, +T5, +T6, +T7, +T8, +T9, +T10](
  p1: Parser[T1],
  p2: Parser[T2],
  p3: Parser[T3],
  p4: Parser[T4],
  p5: Parser[T5],
  p6: Parser[T6],
  p7: Parser[T7],
  p8: Parser[T8],
  p9: Parser[T9],
  p10: Parser[T10]
) extends SequenceParserLike[(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)] { seq =>

  lazy val sequence: IndexedSeq[Parser[Any]] = IndexedSeq(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10)

  def parse(context: ParsingContext): ParsingResult[(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)] = {
    val rb = context.resultBuilder

    val r1 = p1.parse(context)
    if(r1.rejected) return rb.reject

    val r2 = p2.parse(context)
    if(r2.rejected) return rb.reject

    val r3 = p3.parse(context)
    if(r3.rejected) return rb.reject

    val r4 = p4.parse(context)
    if(r4.rejected) return rb.reject

    val r5 = p5.parse(context)
    if(r5.rejected) return rb.reject

    val r6 = p6.parse(context)
    if(r6.rejected) return rb.reject

    val r7 = p7.parse(context)
    if(r7.rejected) return rb.reject

    val r8 = p8.parse(context)
    if(r8.rejected) return rb.reject

    val r9 = p9.parse(context)
    if(r9.rejected) return rb.reject

    val r10 = p10.parse(context)
    if(r10.rejected) return rb.reject


    rb.accept((r1.product, r2.product, r3.product, r4.product, r5.product, r6.product, r7.product, r8.product, r9.product, r10.product))
  }
}

/** Parses 11 expressions, providing strongly-typed results.
  *
  * @param  p1 the parser at position 1 in the sequence.
  * @tparam T1 the product type of the parser at position 1 in the sequence.
  * @param  p2 the parser at position 2 in the sequence.
  * @tparam T2 the product type of the parser at position 2 in the sequence.
  * @param  p3 the parser at position 3 in the sequence.
  * @tparam T3 the product type of the parser at position 3 in the sequence.
  * @param  p4 the parser at position 4 in the sequence.
  * @tparam T4 the product type of the parser at position 4 in the sequence.
  * @param  p5 the parser at position 5 in the sequence.
  * @tparam T5 the product type of the parser at position 5 in the sequence.
  * @param  p6 the parser at position 6 in the sequence.
  * @tparam T6 the product type of the parser at position 6 in the sequence.
  * @param  p7 the parser at position 7 in the sequence.
  * @tparam T7 the product type of the parser at position 7 in the sequence.
  * @param  p8 the parser at position 8 in the sequence.
  * @tparam T8 the product type of the parser at position 8 in the sequence.
  * @param  p9 the parser at position 9 in the sequence.
  * @tparam T9 the product type of the parser at position 9 in the sequence.
  * @param  p10 the parser at position 10 in the sequence.
  * @tparam T10 the product type of the parser at position 10 in the sequence.
  * @param  p11 the parser at position 11 in the sequence.
  * @tparam T11 the product type of the parser at position 11 in the sequence.
  */
case class SequenceParser11[+T1, +T2, +T3, +T4, +T5, +T6, +T7, +T8, +T9, +T10, +T11](
  p1: Parser[T1],
  p2: Parser[T2],
  p3: Parser[T3],
  p4: Parser[T4],
  p5: Parser[T5],
  p6: Parser[T6],
  p7: Parser[T7],
  p8: Parser[T8],
  p9: Parser[T9],
  p10: Parser[T10],
  p11: Parser[T11]
) extends SequenceParserLike[(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)] { seq =>

  lazy val sequence: IndexedSeq[Parser[Any]] = IndexedSeq(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11)

  def parse(context: ParsingContext): ParsingResult[(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)] = {
    val rb = context.resultBuilder

    val r1 = p1.parse(context)
    if(r1.rejected) return rb.reject

    val r2 = p2.parse(context)
    if(r2.rejected) return rb.reject

    val r3 = p3.parse(context)
    if(r3.rejected) return rb.reject

    val r4 = p4.parse(context)
    if(r4.rejected) return rb.reject

    val r5 = p5.parse(context)
    if(r5.rejected) return rb.reject

    val r6 = p6.parse(context)
    if(r6.rejected) return rb.reject

    val r7 = p7.parse(context)
    if(r7.rejected) return rb.reject

    val r8 = p8.parse(context)
    if(r8.rejected) return rb.reject

    val r9 = p9.parse(context)
    if(r9.rejected) return rb.reject

    val r10 = p10.parse(context)
    if(r10.rejected) return rb.reject

    val r11 = p11.parse(context)
    if(r11.rejected) return rb.reject


    rb.accept((r1.product, r2.product, r3.product, r4.product, r5.product, r6.product, r7.product, r8.product, r9.product, r10.product, r11.product))
  }
}

/** Parses 12 expressions, providing strongly-typed results.
  *
  * @param  p1 the parser at position 1 in the sequence.
  * @tparam T1 the product type of the parser at position 1 in the sequence.
  * @param  p2 the parser at position 2 in the sequence.
  * @tparam T2 the product type of the parser at position 2 in the sequence.
  * @param  p3 the parser at position 3 in the sequence.
  * @tparam T3 the product type of the parser at position 3 in the sequence.
  * @param  p4 the parser at position 4 in the sequence.
  * @tparam T4 the product type of the parser at position 4 in the sequence.
  * @param  p5 the parser at position 5 in the sequence.
  * @tparam T5 the product type of the parser at position 5 in the sequence.
  * @param  p6 the parser at position 6 in the sequence.
  * @tparam T6 the product type of the parser at position 6 in the sequence.
  * @param  p7 the parser at position 7 in the sequence.
  * @tparam T7 the product type of the parser at position 7 in the sequence.
  * @param  p8 the parser at position 8 in the sequence.
  * @tparam T8 the product type of the parser at position 8 in the sequence.
  * @param  p9 the parser at position 9 in the sequence.
  * @tparam T9 the product type of the parser at position 9 in the sequence.
  * @param  p10 the parser at position 10 in the sequence.
  * @tparam T10 the product type of the parser at position 10 in the sequence.
  * @param  p11 the parser at position 11 in the sequence.
  * @tparam T11 the product type of the parser at position 11 in the sequence.
  * @param  p12 the parser at position 12 in the sequence.
  * @tparam T12 the product type of the parser at position 12 in the sequence.
  */
case class SequenceParser12[+T1, +T2, +T3, +T4, +T5, +T6, +T7, +T8, +T9, +T10, +T11, +T12](
  p1: Parser[T1],
  p2: Parser[T2],
  p3: Parser[T3],
  p4: Parser[T4],
  p5: Parser[T5],
  p6: Parser[T6],
  p7: Parser[T7],
  p8: Parser[T8],
  p9: Parser[T9],
  p10: Parser[T10],
  p11: Parser[T11],
  p12: Parser[T12]
) extends SequenceParserLike[(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)] { seq =>

  lazy val sequence: IndexedSeq[Parser[Any]] = IndexedSeq(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12)

  def parse(context: ParsingContext): ParsingResult[(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)] = {
    val rb = context.resultBuilder

    val r1 = p1.parse(context)
    if(r1.rejected) return rb.reject

    val r2 = p2.parse(context)
    if(r2.rejected) return rb.reject

    val r3 = p3.parse(context)
    if(r3.rejected) return rb.reject

    val r4 = p4.parse(context)
    if(r4.rejected) return rb.reject

    val r5 = p5.parse(context)
    if(r5.rejected) return rb.reject

    val r6 = p6.parse(context)
    if(r6.rejected) return rb.reject

    val r7 = p7.parse(context)
    if(r7.rejected) return rb.reject

    val r8 = p8.parse(context)
    if(r8.rejected) return rb.reject

    val r9 = p9.parse(context)
    if(r9.rejected) return rb.reject

    val r10 = p10.parse(context)
    if(r10.rejected) return rb.reject

    val r11 = p11.parse(context)
    if(r11.rejected) return rb.reject

    val r12 = p12.parse(context)
    if(r12.rejected) return rb.reject


    rb.accept((r1.product, r2.product, r3.product, r4.product, r5.product, r6.product, r7.product, r8.product, r9.product, r10.product, r11.product, r12.product))
  }
}

/** Parses 13 expressions, providing strongly-typed results.
  *
  * @param  p1 the parser at position 1 in the sequence.
  * @tparam T1 the product type of the parser at position 1 in the sequence.
  * @param  p2 the parser at position 2 in the sequence.
  * @tparam T2 the product type of the parser at position 2 in the sequence.
  * @param  p3 the parser at position 3 in the sequence.
  * @tparam T3 the product type of the parser at position 3 in the sequence.
  * @param  p4 the parser at position 4 in the sequence.
  * @tparam T4 the product type of the parser at position 4 in the sequence.
  * @param  p5 the parser at position 5 in the sequence.
  * @tparam T5 the product type of the parser at position 5 in the sequence.
  * @param  p6 the parser at position 6 in the sequence.
  * @tparam T6 the product type of the parser at position 6 in the sequence.
  * @param  p7 the parser at position 7 in the sequence.
  * @tparam T7 the product type of the parser at position 7 in the sequence.
  * @param  p8 the parser at position 8 in the sequence.
  * @tparam T8 the product type of the parser at position 8 in the sequence.
  * @param  p9 the parser at position 9 in the sequence.
  * @tparam T9 the product type of the parser at position 9 in the sequence.
  * @param  p10 the parser at position 10 in the sequence.
  * @tparam T10 the product type of the parser at position 10 in the sequence.
  * @param  p11 the parser at position 11 in the sequence.
  * @tparam T11 the product type of the parser at position 11 in the sequence.
  * @param  p12 the parser at position 12 in the sequence.
  * @tparam T12 the product type of the parser at position 12 in the sequence.
  * @param  p13 the parser at position 13 in the sequence.
  * @tparam T13 the product type of the parser at position 13 in the sequence.
  */
case class SequenceParser13[+T1, +T2, +T3, +T4, +T5, +T6, +T7, +T8, +T9, +T10, +T11, +T12, +T13](
  p1: Parser[T1],
  p2: Parser[T2],
  p3: Parser[T3],
  p4: Parser[T4],
  p5: Parser[T5],
  p6: Parser[T6],
  p7: Parser[T7],
  p8: Parser[T8],
  p9: Parser[T9],
  p10: Parser[T10],
  p11: Parser[T11],
  p12: Parser[T12],
  p13: Parser[T13]
) extends SequenceParserLike[(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)] { seq =>

  lazy val sequence: IndexedSeq[Parser[Any]] = IndexedSeq(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13)

  def parse(context: ParsingContext): ParsingResult[(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)] = {
    val rb = context.resultBuilder

    val r1 = p1.parse(context)
    if(r1.rejected) return rb.reject

    val r2 = p2.parse(context)
    if(r2.rejected) return rb.reject

    val r3 = p3.parse(context)
    if(r3.rejected) return rb.reject

    val r4 = p4.parse(context)
    if(r4.rejected) return rb.reject

    val r5 = p5.parse(context)
    if(r5.rejected) return rb.reject

    val r6 = p6.parse(context)
    if(r6.rejected) return rb.reject

    val r7 = p7.parse(context)
    if(r7.rejected) return rb.reject

    val r8 = p8.parse(context)
    if(r8.rejected) return rb.reject

    val r9 = p9.parse(context)
    if(r9.rejected) return rb.reject

    val r10 = p10.parse(context)
    if(r10.rejected) return rb.reject

    val r11 = p11.parse(context)
    if(r11.rejected) return rb.reject

    val r12 = p12.parse(context)
    if(r12.rejected) return rb.reject

    val r13 = p13.parse(context)
    if(r13.rejected) return rb.reject


    rb.accept((r1.product, r2.product, r3.product, r4.product, r5.product, r6.product, r7.product, r8.product, r9.product, r10.product, r11.product, r12.product, r13.product))
  }
}

/** Parses 14 expressions, providing strongly-typed results.
  *
  * @param  p1 the parser at position 1 in the sequence.
  * @tparam T1 the product type of the parser at position 1 in the sequence.
  * @param  p2 the parser at position 2 in the sequence.
  * @tparam T2 the product type of the parser at position 2 in the sequence.
  * @param  p3 the parser at position 3 in the sequence.
  * @tparam T3 the product type of the parser at position 3 in the sequence.
  * @param  p4 the parser at position 4 in the sequence.
  * @tparam T4 the product type of the parser at position 4 in the sequence.
  * @param  p5 the parser at position 5 in the sequence.
  * @tparam T5 the product type of the parser at position 5 in the sequence.
  * @param  p6 the parser at position 6 in the sequence.
  * @tparam T6 the product type of the parser at position 6 in the sequence.
  * @param  p7 the parser at position 7 in the sequence.
  * @tparam T7 the product type of the parser at position 7 in the sequence.
  * @param  p8 the parser at position 8 in the sequence.
  * @tparam T8 the product type of the parser at position 8 in the sequence.
  * @param  p9 the parser at position 9 in the sequence.
  * @tparam T9 the product type of the parser at position 9 in the sequence.
  * @param  p10 the parser at position 10 in the sequence.
  * @tparam T10 the product type of the parser at position 10 in the sequence.
  * @param  p11 the parser at position 11 in the sequence.
  * @tparam T11 the product type of the parser at position 11 in the sequence.
  * @param  p12 the parser at position 12 in the sequence.
  * @tparam T12 the product type of the parser at position 12 in the sequence.
  * @param  p13 the parser at position 13 in the sequence.
  * @tparam T13 the product type of the parser at position 13 in the sequence.
  * @param  p14 the parser at position 14 in the sequence.
  * @tparam T14 the product type of the parser at position 14 in the sequence.
  */
case class SequenceParser14[+T1, +T2, +T3, +T4, +T5, +T6, +T7, +T8, +T9, +T10, +T11, +T12, +T13, +T14](
  p1: Parser[T1],
  p2: Parser[T2],
  p3: Parser[T3],
  p4: Parser[T4],
  p5: Parser[T5],
  p6: Parser[T6],
  p7: Parser[T7],
  p8: Parser[T8],
  p9: Parser[T9],
  p10: Parser[T10],
  p11: Parser[T11],
  p12: Parser[T12],
  p13: Parser[T13],
  p14: Parser[T14]
) extends SequenceParserLike[(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)] { seq =>

  lazy val sequence: IndexedSeq[Parser[Any]] = IndexedSeq(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14)

  def parse(context: ParsingContext): ParsingResult[(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)] = {
    val rb = context.resultBuilder

    val r1 = p1.parse(context)
    if(r1.rejected) return rb.reject

    val r2 = p2.parse(context)
    if(r2.rejected) return rb.reject

    val r3 = p3.parse(context)
    if(r3.rejected) return rb.reject

    val r4 = p4.parse(context)
    if(r4.rejected) return rb.reject

    val r5 = p5.parse(context)
    if(r5.rejected) return rb.reject

    val r6 = p6.parse(context)
    if(r6.rejected) return rb.reject

    val r7 = p7.parse(context)
    if(r7.rejected) return rb.reject

    val r8 = p8.parse(context)
    if(r8.rejected) return rb.reject

    val r9 = p9.parse(context)
    if(r9.rejected) return rb.reject

    val r10 = p10.parse(context)
    if(r10.rejected) return rb.reject

    val r11 = p11.parse(context)
    if(r11.rejected) return rb.reject

    val r12 = p12.parse(context)
    if(r12.rejected) return rb.reject

    val r13 = p13.parse(context)
    if(r13.rejected) return rb.reject

    val r14 = p14.parse(context)
    if(r14.rejected) return rb.reject


    rb.accept((r1.product, r2.product, r3.product, r4.product, r5.product, r6.product, r7.product, r8.product, r9.product, r10.product, r11.product, r12.product, r13.product, r14.product))
  }
}

/** Parses 15 expressions, providing strongly-typed results.
  *
  * @param  p1 the parser at position 1 in the sequence.
  * @tparam T1 the product type of the parser at position 1 in the sequence.
  * @param  p2 the parser at position 2 in the sequence.
  * @tparam T2 the product type of the parser at position 2 in the sequence.
  * @param  p3 the parser at position 3 in the sequence.
  * @tparam T3 the product type of the parser at position 3 in the sequence.
  * @param  p4 the parser at position 4 in the sequence.
  * @tparam T4 the product type of the parser at position 4 in the sequence.
  * @param  p5 the parser at position 5 in the sequence.
  * @tparam T5 the product type of the parser at position 5 in the sequence.
  * @param  p6 the parser at position 6 in the sequence.
  * @tparam T6 the product type of the parser at position 6 in the sequence.
  * @param  p7 the parser at position 7 in the sequence.
  * @tparam T7 the product type of the parser at position 7 in the sequence.
  * @param  p8 the parser at position 8 in the sequence.
  * @tparam T8 the product type of the parser at position 8 in the sequence.
  * @param  p9 the parser at position 9 in the sequence.
  * @tparam T9 the product type of the parser at position 9 in the sequence.
  * @param  p10 the parser at position 10 in the sequence.
  * @tparam T10 the product type of the parser at position 10 in the sequence.
  * @param  p11 the parser at position 11 in the sequence.
  * @tparam T11 the product type of the parser at position 11 in the sequence.
  * @param  p12 the parser at position 12 in the sequence.
  * @tparam T12 the product type of the parser at position 12 in the sequence.
  * @param  p13 the parser at position 13 in the sequence.
  * @tparam T13 the product type of the parser at position 13 in the sequence.
  * @param  p14 the parser at position 14 in the sequence.
  * @tparam T14 the product type of the parser at position 14 in the sequence.
  * @param  p15 the parser at position 15 in the sequence.
  * @tparam T15 the product type of the parser at position 15 in the sequence.
  */
case class SequenceParser15[+T1, +T2, +T3, +T4, +T5, +T6, +T7, +T8, +T9, +T10, +T11, +T12, +T13, +T14, +T15](
  p1: Parser[T1],
  p2: Parser[T2],
  p3: Parser[T3],
  p4: Parser[T4],
  p5: Parser[T5],
  p6: Parser[T6],
  p7: Parser[T7],
  p8: Parser[T8],
  p9: Parser[T9],
  p10: Parser[T10],
  p11: Parser[T11],
  p12: Parser[T12],
  p13: Parser[T13],
  p14: Parser[T14],
  p15: Parser[T15]
) extends SequenceParserLike[(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)] { seq =>

  lazy val sequence: IndexedSeq[Parser[Any]] = IndexedSeq(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15)

  def parse(context: ParsingContext): ParsingResult[(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)] = {
    val rb = context.resultBuilder

    val r1 = p1.parse(context)
    if(r1.rejected) return rb.reject

    val r2 = p2.parse(context)
    if(r2.rejected) return rb.reject

    val r3 = p3.parse(context)
    if(r3.rejected) return rb.reject

    val r4 = p4.parse(context)
    if(r4.rejected) return rb.reject

    val r5 = p5.parse(context)
    if(r5.rejected) return rb.reject

    val r6 = p6.parse(context)
    if(r6.rejected) return rb.reject

    val r7 = p7.parse(context)
    if(r7.rejected) return rb.reject

    val r8 = p8.parse(context)
    if(r8.rejected) return rb.reject

    val r9 = p9.parse(context)
    if(r9.rejected) return rb.reject

    val r10 = p10.parse(context)
    if(r10.rejected) return rb.reject

    val r11 = p11.parse(context)
    if(r11.rejected) return rb.reject

    val r12 = p12.parse(context)
    if(r12.rejected) return rb.reject

    val r13 = p13.parse(context)
    if(r13.rejected) return rb.reject

    val r14 = p14.parse(context)
    if(r14.rejected) return rb.reject

    val r15 = p15.parse(context)
    if(r15.rejected) return rb.reject


    rb.accept((r1.product, r2.product, r3.product, r4.product, r5.product, r6.product, r7.product, r8.product, r9.product, r10.product, r11.product, r12.product, r13.product, r14.product, r15.product))
  }
}

/** Parses 16 expressions, providing strongly-typed results.
  *
  * @param  p1 the parser at position 1 in the sequence.
  * @tparam T1 the product type of the parser at position 1 in the sequence.
  * @param  p2 the parser at position 2 in the sequence.
  * @tparam T2 the product type of the parser at position 2 in the sequence.
  * @param  p3 the parser at position 3 in the sequence.
  * @tparam T3 the product type of the parser at position 3 in the sequence.
  * @param  p4 the parser at position 4 in the sequence.
  * @tparam T4 the product type of the parser at position 4 in the sequence.
  * @param  p5 the parser at position 5 in the sequence.
  * @tparam T5 the product type of the parser at position 5 in the sequence.
  * @param  p6 the parser at position 6 in the sequence.
  * @tparam T6 the product type of the parser at position 6 in the sequence.
  * @param  p7 the parser at position 7 in the sequence.
  * @tparam T7 the product type of the parser at position 7 in the sequence.
  * @param  p8 the parser at position 8 in the sequence.
  * @tparam T8 the product type of the parser at position 8 in the sequence.
  * @param  p9 the parser at position 9 in the sequence.
  * @tparam T9 the product type of the parser at position 9 in the sequence.
  * @param  p10 the parser at position 10 in the sequence.
  * @tparam T10 the product type of the parser at position 10 in the sequence.
  * @param  p11 the parser at position 11 in the sequence.
  * @tparam T11 the product type of the parser at position 11 in the sequence.
  * @param  p12 the parser at position 12 in the sequence.
  * @tparam T12 the product type of the parser at position 12 in the sequence.
  * @param  p13 the parser at position 13 in the sequence.
  * @tparam T13 the product type of the parser at position 13 in the sequence.
  * @param  p14 the parser at position 14 in the sequence.
  * @tparam T14 the product type of the parser at position 14 in the sequence.
  * @param  p15 the parser at position 15 in the sequence.
  * @tparam T15 the product type of the parser at position 15 in the sequence.
  * @param  p16 the parser at position 16 in the sequence.
  * @tparam T16 the product type of the parser at position 16 in the sequence.
  */
case class SequenceParser16[+T1, +T2, +T3, +T4, +T5, +T6, +T7, +T8, +T9, +T10, +T11, +T12, +T13, +T14, +T15, +T16](
  p1: Parser[T1],
  p2: Parser[T2],
  p3: Parser[T3],
  p4: Parser[T4],
  p5: Parser[T5],
  p6: Parser[T6],
  p7: Parser[T7],
  p8: Parser[T8],
  p9: Parser[T9],
  p10: Parser[T10],
  p11: Parser[T11],
  p12: Parser[T12],
  p13: Parser[T13],
  p14: Parser[T14],
  p15: Parser[T15],
  p16: Parser[T16]
) extends SequenceParserLike[(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16)] { seq =>

  lazy val sequence: IndexedSeq[Parser[Any]] = IndexedSeq(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16)

  def parse(context: ParsingContext): ParsingResult[(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16)] = {
    val rb = context.resultBuilder

    val r1 = p1.parse(context)
    if(r1.rejected) return rb.reject

    val r2 = p2.parse(context)
    if(r2.rejected) return rb.reject

    val r3 = p3.parse(context)
    if(r3.rejected) return rb.reject

    val r4 = p4.parse(context)
    if(r4.rejected) return rb.reject

    val r5 = p5.parse(context)
    if(r5.rejected) return rb.reject

    val r6 = p6.parse(context)
    if(r6.rejected) return rb.reject

    val r7 = p7.parse(context)
    if(r7.rejected) return rb.reject

    val r8 = p8.parse(context)
    if(r8.rejected) return rb.reject

    val r9 = p9.parse(context)
    if(r9.rejected) return rb.reject

    val r10 = p10.parse(context)
    if(r10.rejected) return rb.reject

    val r11 = p11.parse(context)
    if(r11.rejected) return rb.reject

    val r12 = p12.parse(context)
    if(r12.rejected) return rb.reject

    val r13 = p13.parse(context)
    if(r13.rejected) return rb.reject

    val r14 = p14.parse(context)
    if(r14.rejected) return rb.reject

    val r15 = p15.parse(context)
    if(r15.rejected) return rb.reject

    val r16 = p16.parse(context)
    if(r16.rejected) return rb.reject


    rb.accept((r1.product, r2.product, r3.product, r4.product, r5.product, r6.product, r7.product, r8.product, r9.product, r10.product, r11.product, r12.product, r13.product, r14.product, r15.product, r16.product))
  }
}
