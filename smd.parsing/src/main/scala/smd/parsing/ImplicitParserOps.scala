package smd
package parsing

// This file is automatically generated by an SBT task
// Last Generated: 2013-09-28T04:05:24Z

/** Trait defining implicit classes adding operators to parsers producing tuple values. */
trait ImplicitParserOps {
  // TODO: Check if restriction on inner classes in value classes has been lifted
  /** Implicit class adding operations to parsers producing [[scala.Tuple2]] values. */
  implicit class UpgrayyeddedTupleParser2[T1, T2](val parser: Parser[(T1, T2)]) {
    /** Apply a transformation to the [[scala.Tuple2]] produced by the [[smd.parsing.Parser]] if parsing is successful.
      *
      * @param transform the transformation to be applied to the product [[scala.Tuple2]].
      * @tparam B the transformed product type.
      */
    def ^~ [B](transform: (T1, T2) => B): Parser[B] = new Parser[B] {
      private val t = transform.tupled

      def parse(context: ParsingContext): ParsingResult[B] = {
        val r = parser.parse(context)
        if(r.succeeded) r.copy(t(r.product)) else Failure
      }
    }
  }

  /** Implicit class adding operations to parsers producing [[scala.Tuple3]] values. */
  implicit class UpgrayyeddedTupleParser3[T1, T2, T3](val parser: Parser[(T1, T2, T3)]) {
    /** Apply a transformation to the [[scala.Tuple3]] produced by the [[smd.parsing.Parser]] if parsing is successful.
      *
      * @param transform the transformation to be applied to the product [[scala.Tuple3]].
      * @tparam B the transformed product type.
      */
    def ^~ [B](transform: (T1, T2, T3) => B): Parser[B] = new Parser[B] {
      private val t = transform.tupled

      def parse(context: ParsingContext): ParsingResult[B] = {
        val r = parser.parse(context)
        if(r.succeeded) r.copy(t(r.product)) else Failure
      }
    }
  }

  /** Implicit class adding operations to parsers producing [[scala.Tuple4]] values. */
  implicit class UpgrayyeddedTupleParser4[T1, T2, T3, T4](val parser: Parser[(T1, T2, T3, T4)]) {
    /** Apply a transformation to the [[scala.Tuple4]] produced by the [[smd.parsing.Parser]] if parsing is successful.
      *
      * @param transform the transformation to be applied to the product [[scala.Tuple4]].
      * @tparam B the transformed product type.
      */
    def ^~ [B](transform: (T1, T2, T3, T4) => B): Parser[B] = new Parser[B] {
      private val t = transform.tupled

      def parse(context: ParsingContext): ParsingResult[B] = {
        val r = parser.parse(context)
        if(r.succeeded) r.copy(t(r.product)) else Failure
      }
    }
  }

  /** Implicit class adding operations to parsers producing [[scala.Tuple5]] values. */
  implicit class UpgrayyeddedTupleParser5[T1, T2, T3, T4, T5](val parser: Parser[(T1, T2, T3, T4, T5)]) {
    /** Apply a transformation to the [[scala.Tuple5]] produced by the [[smd.parsing.Parser]] if parsing is successful.
      *
      * @param transform the transformation to be applied to the product [[scala.Tuple5]].
      * @tparam B the transformed product type.
      */
    def ^~ [B](transform: (T1, T2, T3, T4, T5) => B): Parser[B] = new Parser[B] {
      private val t = transform.tupled

      def parse(context: ParsingContext): ParsingResult[B] = {
        val r = parser.parse(context)
        if(r.succeeded) r.copy(t(r.product)) else Failure
      }
    }
  }

  /** Implicit class adding operations to parsers producing [[scala.Tuple6]] values. */
  implicit class UpgrayyeddedTupleParser6[T1, T2, T3, T4, T5, T6](val parser: Parser[(T1, T2, T3, T4, T5, T6)]) {
    /** Apply a transformation to the [[scala.Tuple6]] produced by the [[smd.parsing.Parser]] if parsing is successful.
      *
      * @param transform the transformation to be applied to the product [[scala.Tuple6]].
      * @tparam B the transformed product type.
      */
    def ^~ [B](transform: (T1, T2, T3, T4, T5, T6) => B): Parser[B] = new Parser[B] {
      private val t = transform.tupled

      def parse(context: ParsingContext): ParsingResult[B] = {
        val r = parser.parse(context)
        if(r.succeeded) r.copy(t(r.product)) else Failure
      }
    }
  }

  /** Implicit class adding operations to parsers producing [[scala.Tuple7]] values. */
  implicit class UpgrayyeddedTupleParser7[T1, T2, T3, T4, T5, T6, T7](val parser: Parser[(T1, T2, T3, T4, T5, T6, T7)]) {
    /** Apply a transformation to the [[scala.Tuple7]] produced by the [[smd.parsing.Parser]] if parsing is successful.
      *
      * @param transform the transformation to be applied to the product [[scala.Tuple7]].
      * @tparam B the transformed product type.
      */
    def ^~ [B](transform: (T1, T2, T3, T4, T5, T6, T7) => B): Parser[B] = new Parser[B] {
      private val t = transform.tupled

      def parse(context: ParsingContext): ParsingResult[B] = {
        val r = parser.parse(context)
        if(r.succeeded) r.copy(t(r.product)) else Failure
      }
    }
  }

  /** Implicit class adding operations to parsers producing [[scala.Tuple8]] values. */
  implicit class UpgrayyeddedTupleParser8[T1, T2, T3, T4, T5, T6, T7, T8](val parser: Parser[(T1, T2, T3, T4, T5, T6, T7, T8)]) {
    /** Apply a transformation to the [[scala.Tuple8]] produced by the [[smd.parsing.Parser]] if parsing is successful.
      *
      * @param transform the transformation to be applied to the product [[scala.Tuple8]].
      * @tparam B the transformed product type.
      */
    def ^~ [B](transform: (T1, T2, T3, T4, T5, T6, T7, T8) => B): Parser[B] = new Parser[B] {
      private val t = transform.tupled

      def parse(context: ParsingContext): ParsingResult[B] = {
        val r = parser.parse(context)
        if(r.succeeded) r.copy(t(r.product)) else Failure
      }
    }
  }

  /** Implicit class adding operations to parsers producing [[scala.Tuple9]] values. */
  implicit class UpgrayyeddedTupleParser9[T1, T2, T3, T4, T5, T6, T7, T8, T9](val parser: Parser[(T1, T2, T3, T4, T5, T6, T7, T8, T9)]) {
    /** Apply a transformation to the [[scala.Tuple9]] produced by the [[smd.parsing.Parser]] if parsing is successful.
      *
      * @param transform the transformation to be applied to the product [[scala.Tuple9]].
      * @tparam B the transformed product type.
      */
    def ^~ [B](transform: (T1, T2, T3, T4, T5, T6, T7, T8, T9) => B): Parser[B] = new Parser[B] {
      private val t = transform.tupled

      def parse(context: ParsingContext): ParsingResult[B] = {
        val r = parser.parse(context)
        if(r.succeeded) r.copy(t(r.product)) else Failure
      }
    }
  }

  /** Implicit class adding operations to parsers producing [[scala.Tuple10]] values. */
  implicit class UpgrayyeddedTupleParser10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10](val parser: Parser[(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10)]) {
    /** Apply a transformation to the [[scala.Tuple10]] produced by the [[smd.parsing.Parser]] if parsing is successful.
      *
      * @param transform the transformation to be applied to the product [[scala.Tuple10]].
      * @tparam B the transformed product type.
      */
    def ^~ [B](transform: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) => B): Parser[B] = new Parser[B] {
      private val t = transform.tupled

      def parse(context: ParsingContext): ParsingResult[B] = {
        val r = parser.parse(context)
        if(r.succeeded) r.copy(t(r.product)) else Failure
      }
    }
  }

  /** Implicit class adding operations to parsers producing [[scala.Tuple11]] values. */
  implicit class UpgrayyeddedTupleParser11[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11](val parser: Parser[(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11)]) {
    /** Apply a transformation to the [[scala.Tuple11]] produced by the [[smd.parsing.Parser]] if parsing is successful.
      *
      * @param transform the transformation to be applied to the product [[scala.Tuple11]].
      * @tparam B the transformed product type.
      */
    def ^~ [B](transform: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11) => B): Parser[B] = new Parser[B] {
      private val t = transform.tupled

      def parse(context: ParsingContext): ParsingResult[B] = {
        val r = parser.parse(context)
        if(r.succeeded) r.copy(t(r.product)) else Failure
      }
    }
  }

  /** Implicit class adding operations to parsers producing [[scala.Tuple12]] values. */
  implicit class UpgrayyeddedTupleParser12[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12](val parser: Parser[(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12)]) {
    /** Apply a transformation to the [[scala.Tuple12]] produced by the [[smd.parsing.Parser]] if parsing is successful.
      *
      * @param transform the transformation to be applied to the product [[scala.Tuple12]].
      * @tparam B the transformed product type.
      */
    def ^~ [B](transform: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12) => B): Parser[B] = new Parser[B] {
      private val t = transform.tupled

      def parse(context: ParsingContext): ParsingResult[B] = {
        val r = parser.parse(context)
        if(r.succeeded) r.copy(t(r.product)) else Failure
      }
    }
  }

  /** Implicit class adding operations to parsers producing [[scala.Tuple13]] values. */
  implicit class UpgrayyeddedTupleParser13[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13](val parser: Parser[(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13)]) {
    /** Apply a transformation to the [[scala.Tuple13]] produced by the [[smd.parsing.Parser]] if parsing is successful.
      *
      * @param transform the transformation to be applied to the product [[scala.Tuple13]].
      * @tparam B the transformed product type.
      */
    def ^~ [B](transform: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13) => B): Parser[B] = new Parser[B] {
      private val t = transform.tupled

      def parse(context: ParsingContext): ParsingResult[B] = {
        val r = parser.parse(context)
        if(r.succeeded) r.copy(t(r.product)) else Failure
      }
    }
  }

  /** Implicit class adding operations to parsers producing [[scala.Tuple14]] values. */
  implicit class UpgrayyeddedTupleParser14[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14](val parser: Parser[(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14)]) {
    /** Apply a transformation to the [[scala.Tuple14]] produced by the [[smd.parsing.Parser]] if parsing is successful.
      *
      * @param transform the transformation to be applied to the product [[scala.Tuple14]].
      * @tparam B the transformed product type.
      */
    def ^~ [B](transform: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14) => B): Parser[B] = new Parser[B] {
      private val t = transform.tupled

      def parse(context: ParsingContext): ParsingResult[B] = {
        val r = parser.parse(context)
        if(r.succeeded) r.copy(t(r.product)) else Failure
      }
    }
  }

  /** Implicit class adding operations to parsers producing [[scala.Tuple15]] values. */
  implicit class UpgrayyeddedTupleParser15[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15](val parser: Parser[(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15)]) {
    /** Apply a transformation to the [[scala.Tuple15]] produced by the [[smd.parsing.Parser]] if parsing is successful.
      *
      * @param transform the transformation to be applied to the product [[scala.Tuple15]].
      * @tparam B the transformed product type.
      */
    def ^~ [B](transform: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15) => B): Parser[B] = new Parser[B] {
      private val t = transform.tupled

      def parse(context: ParsingContext): ParsingResult[B] = {
        val r = parser.parse(context)
        if(r.succeeded) r.copy(t(r.product)) else Failure
      }
    }
  }

  /** Implicit class adding operations to parsers producing [[scala.Tuple16]] values. */
  implicit class UpgrayyeddedTupleParser16[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16](val parser: Parser[(T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16)]) {
    /** Apply a transformation to the [[scala.Tuple16]] produced by the [[smd.parsing.Parser]] if parsing is successful.
      *
      * @param transform the transformation to be applied to the product [[scala.Tuple16]].
      * @tparam B the transformed product type.
      */
    def ^~ [B](transform: (T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16) => B): Parser[B] = new Parser[B] {
      private val t = transform.tupled

      def parse(context: ParsingContext): ParsingResult[B] = {
        val r = parser.parse(context)
        if(r.succeeded) r.copy(t(r.product)) else Failure
      }
    }
  }

}