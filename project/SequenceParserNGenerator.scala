import sbt._

class SequenceParserNGenerator(n: Int, maxN: Int) extends FileGenerator(_/"parsing"/s"SequenceParser$n.scala") {
  private def className(x: Int = n) = s"SequenceParser$x"
  private def qualifiedClassName(x: Int = n) = s"smd.parsing.${className(x)}"

  private def ordinal(x: Int) = {
    x + IndexedSeq("th","st","nd","rd","th")(if(10 <= x && x <= 19) 4 else math.min(4, x % 10))
  }

  private val types =            (1 to n).map("T"+_)
  private val typeList =         types.mkString(", ")
  private val productTupleType = s"($typeList)"

  def content: String =
    s"""
    |package smd
    |package parsing
    |
    |import scala.{Product, Product$n}
    |
    |// THIS FILE IS AUTOMATICALLY GENERATED
    |// Generated at: $timeStamp
    |
    |/** Parses $n expressions, providing strongly-typed results.
    |  * ${(1 to n).map({ i => s"""
    |  * @param  _${i.toString.padTo(2, ' ')} the ${ordinal(i)} parser in the sequence.
    |  * @tparam T${i.toString.padTo(2, ' ')} the product type of the ${ordinal(i)} parser in the sequence.""".stripMargin }).mkString("")}
    |  */
    |case class ${className()}[${types.map("+"+_).mkString(", ")}](
    |  ${(1 to n).map(i => s"_$i: Parser[T$i]").mkString(", ")}
    |) extends Product$n[${types.map(t => s"Parser[$t]").mkString(", ")}]
    |     with Product
    |     with Parser[$productTupleType]
    |{
    |  def parse(context: ParsingContext): ParsingResult[$productTupleType] = {
    |    val rb = context.resultBuilder
    |
    |    ${(1 to n).map({ i => s"""
    |    val r$i = _$i.parse(context)
    |    if(r$i.failed) return rb.failure
    |    """.trim.stripMargin }).mkString("\n").trim}
    |
    |    rb.success((${(1 to n).map(i => s"r$i.product").mkString(", ")}))
    |  }
    |}
    |
    |object SequenceParser$n {
    |$sequencingHeuristic
    |}
    """.trim.stripMargin

  def sequencingHeuristic: String =
    if(n == maxN)
    s"""
    |  implicit def sequencingHeuristic[$typeList, A]: SequencingHeuristic[
    |    /*  left: */ ${className()}[$typeList],
    |    /* right: */ Parser[A],
    |    /*  dest: */ SequenceParser
    |  ] =
    |    SequencingHeuristic.create((l, r) => SequenceParser(${(1 to n).map("l._"+_).mkString(", ")}, r))
    """.trim.stripMargin
    else
    s"""
    |  /** Implicit [[smd.parsing.SequencingHeuristic]] which can be used to combine an [[${qualifiedClassName()}]]
    |    * and an [[smd.parsing.Parser]] into an [[${qualifiedClassName(n+1)}]]. */
    |  implicit def sequencingHeuristic[$typeList, A]: SequencingHeuristic[
    |    /*  left: */ ${className()}[$typeList],
    |    /* right: */ Parser[A],
    |    /*  dest: */ ${className(n+1)}[$typeList, A]
    |  ] =
    |    SequencingHeuristic.create((l, r) => ${className(n+1)}(${(1 to n).map("l._"+_).mkString(", ")}, r))
    """.trim.stripMargin
}
